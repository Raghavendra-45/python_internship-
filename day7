# encapsulation:
class bikes:
    def __init__(self,name,cc,m,cost):
        self.name=name
        self.cc=cc
        self.m=m
        self.cost=cost
    def performance(self):
        print("abt bikes:",self.name,self.cc,self.m,self.cost)
gt=bikes("gt",650,12,4)
duke=bikes("duke",390,30,2)
gt.performance()
duke.performance()



# instance,class,static methods:
class cars:
    wheels=4
    def __init__(self,mil,car):
        self.mil=mil
        self.car=car
    def get_mil(self):
        return c1.mil
    def set_mil(self):
        c1.mil=12
    @staticmethod
    def info():
        print("hi hello")
    @classmethod
    def infor(cls):
        return cls.wheels
print(cars.infor())
c1=cars(10,"BMW")
c2=cars(15,"audi")
c1.wheels=9
print(c1.mil)
print(c1.wheels)
print(c2.wheels)
print(c1.get_mil())
print(c1.set_mil())
print(c1.mil)



# duck typing: (method overriding)
class pycharm:
    def execute(self):
        print("compiling")
        print("Running")
class myeditor:
    def execute(self):
        print("debugging")
        print("printing error")
        print("compiling")
        print("running")
class laptop:
    def code(self,ide):
        ide.execute()
ide=pycharm()
lap1=laptop()
lap1.code(ide)



# operator overloading(magic methods):
class student:
    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2
    def __add__(self,other):
        m1=self.m1+other.m1
        m2=self.m2+other.m2
        s3=student(m1,m2)
        return s3
    def __gt__(self,other):
        r1=self.m1+self.m2
        r2=other.m1+other.m2
        if r1>r2:
            return True
        else:
            return False
s1=student(59,65)
s2=student(67,85)
s3=s1+s2
print(s3.m1)
print(s3.m2)
if s1>s2:
    print("s1 is having more marks then s2")
else:
    print("s2 is having more marks then s1")




# method overloading:
class math:
    def add(self,a=0,b=0,c=0):
        return a+b+c
m=math()
print(m.add(1,2))
print(m.add(1,2,3))
print(m.add())


# single_level inheritance:
class Animal:
    def sound(self):
        return "Animals make different sounds"
class Dog(Animal):
    def sound(self):
        return "dog barks"
d=Dog()
print(d.sound())



# multiple inheritance:
class engine:
    def engine_info(self):
        return "this is an engine"
class wheels:
    def wheels_info(self):
        return "car has 4 wheels"
class car(engine,wheels):
    def car_info(self):
        return "this a car"
c=car()
print(c.engine_info())
print(c.wheels_info())
print(c.car_info())



# multi_level inheritance:
class Animal:
    def species(self):
        return "this is an animal"
class Mammal(Animal):
    def category(self):
        return "this is a mammal"
class Human(Mammal):
    def speak(self):
        return "humans can speak"
h=Human()
print(h.species())
print(h.category())
print(h.speak())




# hierarchical inheritance:
class vehicle:
    def fuel_type(self):
        return "vehicles can use petrol,disel and LPG"
class car(vehicle):
    def type(self):
        return "car is a 4-wheeler"
class bike(vehicle):
    def type(self):
        return "bike is a 2 wheeler"
c=car()
b=bike()
print(c.fuel_type())
print(c.type())
print(b.type())



# hybrid inheritance:
class A:
    def display(self):
        print("this is A class")
class B(A):
    def display(self):
        print("this is B class")
class C:
    def show(self):
        print("this is C class")
class D(B,C):
    def display(self):
        print("This is D class")
d1=D()
d1.display()
d1.show()
print(D.mro()) #method resolution order(mro)



# linear search:
def search(list1,key):
    for i in range(len(list1)):
        if key==list1[i]:
            print("element found at index:",i)
            break
    else:
        print("element not found")
list1=[2,4,5,6,1,7,8,9,11]
key=int(input())
search(list1,key)



# binary search:
nums=[1,3,5,7,9]
key=5
low,high=0,len(nums)-1
result=-1
while low<=high:
    mid=(low+high)//2
    if nums[mid]==key:
        result=mid
        break
    elif nums[mid]<key:
        low=mid+1
    else:
        high=mid-1
if result!=-1:
    print("element found at index:",result)
else:
    print("not found")



# first occurance and last occurance:
def first_last_occurrence(arr, key):
    first = -1
    last = -1
    for i in range(len(arr)):
        if arr[i] == key:
            if first == -1:  
                first = i
            last = i         
    return first, last
arr = [1, 2, 3, 2, 4, 2, 5, 6]
key = 2
first, last = first_last_occurrence(arr, key)
if first == -1:
    print( "not found")
else:
    print(first)
    print(last)



# find the min element from rotated sorted array:
nums=[4,5,6,7,1,2]
low,high=0,len(nums)-1
while low<high:
    mid=(low+high)//2
    if nums[mid]>nums[high]:
        low=mid+1
    else:
        high=mid
print(nums[low])



# find the peak element in a given array:
nums=[1,2,3,1]
low,high=0,len(nums)
while low<high:
    mid=(low+high)//2
    if nums[mid] < nums[mid+1]:
        low=mid+1
    else:
        high=mid
print(nums[low])



# find the square root of a number using binary search:
n=16
low,high=0,n
result=0
while low<=high:
    mid=(low+high)//2
    if mid*mid<=n:
        result=mid
        low=mid+1
    else:
        high=mid-1
print(result)
